# 盛最多水的容器

难度：中等

## 题目

给定一个长度为 n 的整数数组 `height`。有 n 条垂直线，第 i 条线的两个端点是 `(i, 0)` 和 `(i, height[i])`。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**注意**：你不能倾斜容器。

## 示例

```
输入：height = [1,8,6,2,5,4,8,3,7]
输出：49
解释：选择索引 1 和 8（高度分别为 8 和 7）
面积 = (8-1) × min(8,7) = 7 × 7 = 49
```

```
输入：height = [1,1]
输出：1
```

```
输入：height = [4,3,2,1,4]
输出：16
解释：选择索引 0 和 4
面积 = (4-0) × min(4,4) = 4 × 4 = 16
```

## 解法

### 暴力解法 O(n²)

遍历所有两条线的组合，计算每种组合的面积。

```python
def maxArea(self, height: List[int]) -> int:
    max_area = 0
    for i in range(len(height)):
        for j in range(i+1, len(height)):
            area = (j - i) * min(height[i], height[j])
            max_area = max(max_area, area)
    return max_area
```

### 对撞指针 + 贪心 O(n) ✓

核心思路：从两端开始，**总是移动较矮的那个指针**。

**为什么移动较矮的指针？**

面积 = 宽度 × 高度（木桶效应，取较矮的）

假设 `height[left] < height[right]`：
- **移动 right**（较高的）：宽度减小，高度最多还是 `height[left]`（因为 left 还是那个矮的） → 面积**一定不会变大**
- **移动 left**（较矮的）：宽度减小，但高度**有可能**增加 → 面积**有可能变大**

所以贪心策略：总是移动较矮的指针，才有机会找到更大的面积。

```python
def maxArea(self, height: List[int]) -> int:
    max_area = 0
    left, right = 0, len(height) - 1

    while left < right:
        # 计算当前面积
        area = (right - left) * min(height[left], height[right])
        max_area = max(max_area, area)

        # 移动较矮的指针
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1

    return max_area
```

## 复杂度

- 时间：O(n)，每个元素最多访问一次
- 空间：O(1)

## 要点

1. **对撞指针**：从两端向中间收缩，缩小搜索空间
2. **贪心策略**：总是移动较矮的指针
3. **木桶效应**：高度由较短的那条线决定
4. **宽度与高度的权衡**：宽度递减，所以只有在高度可能增加时才值得移动
5. 证明正确性：移动较高的指针不可能产生更大面积（宽度减小且高度不增加）

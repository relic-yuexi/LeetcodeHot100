# 三数之和（中等）

## 题目

给你一个整数数组 `nums`，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k`，同时还满足 `nums[i] + nums[j] + nums[k] == 0`。

请你返回所有和为 0 且**不重复**的三元组。

## 示例

```
输入：nums = [-1, 0, 1, 2, -1, -4]
输出：[[-1, -1, 2], [-1, 0, 1]]
```

```
输入：nums = [0, 1, 1]
输出：[]
```

```
输入：nums = [0, 0, 0]
输出：[[0, 0, 0]]
```

## 解法

### 排序 + 双指针 ✓

先排序，然后固定第一个数 `nums[i]`，对剩余部分用对撞双指针找两数之和等于 `-nums[i]` 的组合。去重利用排序后相同元素相邻的特性，直接跳过。

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        max_len = len(nums)
        res = []

        for i, num in enumerate(nums):
            target = 0 - num
            left = i + 1
            right = max_len - 1
            if i > 0 and nums[i] == nums[i - 1]:
                continue

            while left < right:
                c_res = nums[left] + nums[right]
                if c_res == target:
                    res.append([num, nums[left], nums[right]])
                    left += 1
                    right -= 1
                    while left < right and nums[left] == nums[left - 1]:
                        left += 1
                    while left < right and nums[right] == nums[right + 1]:
                        right -= 1
                elif c_res > target:
                    right -= 1
                elif c_res < target:
                    left += 1

        return res
```

## 复杂度

| | 排序 + 双指针 |
|------|------|
| 时间 | O(n²) |
| 空间 | O(1)（不计排序和结果） |

## 要点

1. **排序是关键**：排序后才能用双指针，也让去重变得简单（相同元素相邻，直接跳过）
2. **两层去重**：外层跳过相同的 `nums[i]`，内层找到解后跳过相同的 `nums[left]` 和 `nums[right]`
3. **找到解后双指针都要移动**：否则会死循环
4. **将三数之和转化为两数之和**：固定一个数，问题降维

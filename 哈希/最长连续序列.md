# 最长连续序列

难度：中等

## 题目

给定一个未排序的整数数组 `nums`，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

**要求**：算法的时间复杂度必须是 O(n)。

## 示例

```
输入：nums = [100, 4, 200, 1, 3, 2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

```
输入：nums = [0, 3, 7, 2, 5, 8, 4, 6, 0, 1]
输出：9
解释：最长数字连续序列是 [0, 1, 2, 3, 4, 5, 6, 7, 8]。
```

## 解法

### 排序解法 O(n log n)

先排序再遍历统计连续序列长度。但时间复杂度不满足要求。

### 哈希表 + 智能起点 O(n) ✓

核心思路：用哈希表存储所有数字，然后只从**连续序列的起点**开始往后统计长度。

**关键优化**：如何判断起点？
- 如果 `num - 1` 存在于集合中，说明 `num` 不是起点，跳过
- 如果 `num - 1` 不存在，说明 `num` 是起点，从这里开始往后数

这样每个连续序列只会被遍历一次，保证 O(n) 时间复杂度。

```python
def longestConsecutive(self, nums: List[int]) -> int:
    if not nums:
        return 0

    num_set = set(nums)
    max_len = 0

    for num in num_set:
        # 只有当 num-1 不存在时，num 才是序列起点
        if (num - 1) not in num_set:
            current = num
            length = 1

            # 从起点往后数
            while (current + 1) in num_set:
                current += 1
                length += 1

            max_len = max(max_len, length)

    return max_len
```

## 复杂度

- 时间：O(n)，虽然有嵌套循环，但每个数字最多被访问两次（外层一次，内层一次）
- 空间：O(n)

## 要点

1. 用 `set` 实现 O(1) 查找
2. 智能判断序列起点：`num - 1 not in set`
3. 只从起点开始统计，避免重复遍历
4. 时间复杂度分析：虽然有 while 循环，但每个数字最多进入 while 一次，总体仍是 O(n)

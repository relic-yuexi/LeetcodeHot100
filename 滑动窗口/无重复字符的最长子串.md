# 无重复字符的最长子串

难度：中等

## 题目

给定一个字符串 `s`，请你找出其中不含有重复字符的**最长子串**的长度。

- `0 <= s.length <= 5 * 10⁴`
- `s` 由英文字母、数字、符号和空格组成

## 示例

```
输入：s = "abcabcbb"
输出：3
解释：因为无重复字符的最长子串是 "abc"，所以其长度为 3。

输入：s = "bbbbb"
输出：1

输入：s = "pwwkew"
输出：3
解释：无重复字符的最长子串是 "wke"，长度为 3。注意 "pwke" 是子序列不是子串。
```

## 解法

### 暴力解法 O(n²)

对每个起始位置，向右扫描直到遇到重复字符，记录最大长度。

### 滑动窗口 + 哈希表 O(n) ✓

用 dict 记录每个字符最后出现的位置，右指针遍历字符串，遇到重复时左指针直接跳到 `max(left, d[char] + 1)`，避免逐步移动。

关键点：dict 中可能存在窗口外的"过期"记录，用 `max` 保证左指针不会回退。窗口大小用 `right - left + 1` 计算，不能用 `len(dict)`。

```python
def lengthOfLongestSubstring(self, s: str) -> int:
    res_num = 0
    l = len(s)
    left, right = 0, 0
    d = {}
    while left < l and right < l:
        if s[right] in d:
            left = max(left, d[s[right]] + 1)
        d[s[right]] = right
        res_num = max(res_num, right - left + 1)
        right += 1
    return res_num
```

## 复杂度

- 时间：O(n)，右指针遍历一遍字符串
- 空间：O(min(n, m))，m 为字符集大小，dict 最多存 m 个字符

## 要点

1. 右指针只前进不回退，保证 O(n)
2. `max(left, d[char] + 1)` 处理"过期"记录，不需要清空 dict
3. 窗口大小 = `right - left + 1`，不能用 `len(dict)` 代替

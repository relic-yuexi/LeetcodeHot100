# 找到字符串中所有字母异位词

难度：中等

## 题目

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的异位词的子串，返回这些子串的起始索引。

- `1 <= s.length, p.length <= 3 * 10⁴`
- `s` 和 `p` 仅包含小写字母

## 示例

```
输入：s = "cbaebabacd", p = "abc"
输出：[0, 6]
解释：
起始索引等于 0 的子串是 "cba"，它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac"，它是 "abc" 的异位词。

输入：s = "abab", p = "ab"
输出：[0, 1, 2]
```

## 解法

### 暴力解法 O(n·m·log(m))

对每个位置取长度为 `len(p)` 的子串排序，与排序后的 `p` 比较。

### 定长滑动窗口 + 频次字典 O(n) ✓

异位词的本质是字符频次相同。维护两个频次字典：`d_p` 固定不变，`d_s` 随窗口滑动增量更新。

窗口大小固定为 `len(p)`，每次右移一格：移除左边字符、加入右边字符，只更新两个字符，O(1) 完成。

关键点：删除字符时，计数减到 0 要把 key 删掉，否则 `d_s == d_p` 比较会因为多余的 key 而不相等。手写 dict 比 `Counter` 更快，因为没有类继承开销。

```python
def findAnagrams(self, s: str, p: str) -> List[int]:
    l_p = len(p)
    l_s = len(s)
    if l_s < l_p:
        return []
    d_p = {}
    d_s = {}
    for i, c in enumerate(p):
        if c in d_p:
            d_p[c] += 1
        else:
            d_p[c] = 1
        if s[i] in d_s:
            d_s[s[i]] += 1
        else:
            d_s[s[i]] = 1
    r_s = []
    for i, c in enumerate(s):
        if d_s == d_p:
            r_s.append(i)
        if i == (l_s - l_p):
            break
        d_s[c] -= 1
        if d_s[c] == 0:
            d_s.pop(c)
        right = i + l_p
        if s[right] in d_s:
            d_s[s[right]] += 1
        else:
            d_s[s[right]] = 1
    return r_s
```

## 复杂度

- 时间：O(n)，窗口滑动 n-m 次，每次更新和比较都是 O(1)（字符集大小固定为 26）
- 空间：O(1)，字典最多存 26 个字母

## 要点

1. 异位词 = 字符频次相同，用 Counter/dict 比较
2. 定长窗口每次只增量更新两个字符，不需要重建
3. 计数减到 0 时要删 key，保证字典比较正确
